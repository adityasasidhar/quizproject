<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/utils.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils.py" />
              <option name="originalContent" value="import os&#10;import re&#10;import json&#10;from typing import List, Dict, Tuple, Any&#10;from fpdf import FPDF&#10;from PyPDF2 import PdfReader&#10;&#10;&#10;def load_text_file(file_path: str) -&gt; str:&#10;    &quot;&quot;&quot;Load and return the content of a text file.&quot;&quot;&quot;&#10;    with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as file:&#10;        return file.read()&#10;&#10;def load_pdf_file(file_path: str) -&gt; str:&#10;    &quot;&quot;&quot;Extract and return text from a PDF file.&quot;&quot;&quot;&#10;    reader = PdfReader(file_path)&#10;    text = &quot;&quot;&#10;    for page in reader.pages:&#10;        page_text = page.extract_text() or &quot;&quot;&#10;        text += page_text&#10;    return text&#10;&#10;def load_papers(directory: str) -&gt; List[str]:&#10;    &quot;&quot;&quot;Load all .txt and .pdf files from a directory and return their contents.&quot;&quot;&quot;&#10;    papers = []&#10;    try:&#10;        for filename in os.listdir(directory):&#10;            file_path = os.path.join(directory, filename)&#10;            if filename.endswith(&quot;.txt&quot;):&#10;                try:&#10;                    papers.append(load_text_file(file_path))&#10;                except Exception as e:&#10;                    print(f&quot;Error reading text file {filename}: {e}&quot;)&#10;            elif filename.endswith(&quot;.pdf&quot;):&#10;                try:&#10;                    papers.append(load_pdf_file(file_path))&#10;                except Exception as e:&#10;                    print(f&quot;Error reading PDF {filename}: {e}&quot;)&#10;        print(f&quot;Loaded {len(papers)} papers&quot;)&#10;        return papers&#10;    except Exception as e:&#10;        print(f&quot;Error loading papers: {e}&quot;)&#10;        return []&#10;&#10;# ------------------ Answer Checking Utilities ------------------&#10;&#10;def load_json_file(filepath: str) -&gt; Any:&#10;    &quot;&quot;&quot;Load and return JSON data from a file.&quot;&quot;&quot;&#10;    with open(filepath, 'r') as f:&#10;        return json.load(f)&#10;&#10;def compare_answers(generated_paper: List[Dict], submitted_answers: Dict) -&gt; Tuple[int, List[Dict]]:&#10;    &quot;&quot;&quot;Compare submitted answers with correct answers and return score and detailed results.&quot;&quot;&quot;&#10;    score = 0&#10;    results = []&#10;    for question in generated_paper:&#10;        q_num = question.get('question_number')&#10;        correct_answer = question.get('answer')&#10;        submitted_answer = submitted_answers.get(str(q_num)) or submitted_answers.get(q_num)&#10;        is_correct = (str(submitted_answer).strip().lower() == str(correct_answer).strip().lower())&#10;        results.append({&#10;            'question_number': q_num,&#10;            'correct_answer': correct_answer,&#10;            'submitted_answer': submitted_answer,&#10;            'is_correct': is_correct&#10;        })&#10;        if is_correct:&#10;            score += 1&#10;    return score, results&#10;&#10;def print_results(generated_paper: List[Dict], score: int, results: List[Dict]):&#10;    &quot;&quot;&quot;Print summary and detailed results of answer comparison.&quot;&quot;&quot;&#10;    print(f&quot;Total Questions: {len(generated_paper)}&quot;)&#10;    print(f&quot;Correct Answers: {score}&quot;)&#10;    print(&quot;Detailed Results:&quot;)&#10;    for res in results:&#10;        print(&#10;            f&quot;Q{res['question_number']}: Submitted: {res['submitted_answer']} | Correct: {res['correct_answer']} | {'Correct' if res['is_correct'] else 'Incorrect'}&quot;&#10;        )&#10;&#10;def check_online_paper(generated_paper_filepath: str, submitted_answer_sheet_filepath: str, exam_name: str):&#10;    &quot;&quot;&quot;&#10;    Compares the submitted answers with the generated paper and prints the result for each question.&#10;    Returns a dict containing score and detailed results.&#10;    &quot;&quot;&quot;&#10;    if not os.path.exists(generated_paper_filepath):&#10;        print(f&quot;File {generated_paper_filepath} does not exist.&quot;)&#10;        return None&#10;    if not generated_paper_filepath.endswith(&quot;.json&quot;):&#10;        print(&quot;Generated paper file is not a JSON file.&quot;)&#10;        return None&#10;&#10;    submitted_answers = load_json_file(submitted_answer_sheet_filepath)&#10;    generated_paper = load_json_file(generated_paper_filepath)&#10;    score, results = compare_answers(generated_paper, submitted_answers)&#10;    print_results(generated_paper, score, results)&#10;    return {&#10;        'score': score,&#10;        'total': len(generated_paper),&#10;        'results': results&#10;    }&#10;&#10;# ------------------ Text Cleaning Utilities ------------------&#10;&#10;def clean_text(text: str) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    Cleans and replaces special characters in the text for better readability.&#10;    &quot;&quot;&quot;&#10;    replacements = {&#10;        '√': 'sqrt', '±': '+/-', '°': ' degrees', '×': 'x', '÷': '/',&#10;        '≠': '!=', '≤': '&lt;=', '≥': '&gt;=', '∞': 'infinity', 'π': 'pi',&#10;        'μ': 'u', 'Δ': 'delta', 'α': 'alpha', 'β': 'beta', 'γ': 'gamma'&#10;    }&#10;    for old, new in replacements.items():&#10;        text = text.replace(old, new)&#10;    text = re.sub(r'[^\x00-\x7F]+', '', text)&#10;    return text&#10;&#10;# ------------------ PDF Generation Utilities ------------------&#10;&#10;def group_questions_by_subject(data: List[Dict]) -&gt; Dict[str, List[Dict]]:&#10;    &quot;&quot;&quot;Group questions by subject.&quot;&quot;&quot;&#10;    subjects = {}&#10;    for item in data:&#10;        subject = item.get('subject', 'General')&#10;        subjects.setdefault(subject, []).append(item)&#10;    return subjects&#10;&#10;        question_pdf.ln(8)&#10;&#10;        # Add questions to PDF, grouped by subject&#10;        for subject, questions in subjects.items():&#10;            question_pdf.set_font(&quot;Arial&quot;, 'B', 14)&#10;            question_pdf.cell(0, 10, txt=f&quot;{subject} Section&quot;, ln=True)&#10;            question_pdf.set_font(&quot;Arial&quot;, size=12)&#10;            question_pdf.ln(2)&#10;            for item in questions:&#10;                question_text = clean_text(item['question'])&#10;                question_pdf.multi_cell(0, 10, f&quot;Q{item['question_number']}: {question_text}&quot;)&#10;                if 'options' in item and item['options']:&#10;                    for idx, opt in enumerate(item['options']):&#10;                        option_text = clean_text(opt)&#10;                        question_pdf.multi_cell(0, 8, f&quot;    {chr(65 + idx)}. {option_text}&quot;)&#10;                question_pdf.ln(4)&#10;            question_pdf.ln(6)&#10;&#10;        question_pdf_path = filepath.replace(&quot;.json&quot;, &quot;_questions.pdf&quot;)&#10;        question_pdf.output(question_pdf_path)&#10;&#10;        # Generate Answer Sheet PDF&#10;        answer_pdf = FPDF()&#10;        answer_pdf.add_page()&#10;        answer_pdf.set_font(&quot;Arial&quot;, 'B', 16)&#10;        answer_pdf.cell(0, 12, txt=&quot;Answer Sheet&quot;, ln=True, align='C')&#10;        answer_pdf.ln(8)&#10;&#10;        # Add answers to PDF, grouped by subject&#10;        for subject, questions in subjects.items():&#10;            answer_pdf.set_font(&quot;Arial&quot;, 'B', 14)&#10;            answer_pdf.cell(0, 10, txt=f&quot;{subject} Section&quot;, ln=True)&#10;            answer_pdf.set_font(&quot;Arial&quot;, size=12)&#10;            answer_pdf.ln(2)&#10;            for item in questions:&#10;                answer_text = clean_text(str(item['answer']))&#10;                answer_pdf.cell(0, 10, f&quot;Q{item['question_number']}: {answer_text}&quot;, ln=True)&#10;            answer_pdf.ln(6)&#10;&#10;        answer_pdf_path = filepath.replace(&quot;.json&quot;, &quot;_answers.pdf&quot;)&#10;        answer_pdf.output(answer_pdf_path)&#10;&#10;        return question_pdf_path, answer_pdf_path" />
              <option name="updatedContent" value="import os&#10;import re&#10;import json&#10;from typing import List, Dict, Tuple, Any&#10;from fpdf import FPDF&#10;from PyPDF2 import PdfReader&#10;&#10;# ------------------ File Loading Utilities ------------------&#10;&#10;def load_text_file(file_path: str) -&gt; str:&#10;    &quot;&quot;&quot;Load and return the content of a text file.&quot;&quot;&quot;&#10;    with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as file:&#10;        return file.read()&#10;&#10;def load_pdf_file(file_path: str) -&gt; str:&#10;    &quot;&quot;&quot;Extract and return text from a PDF file.&quot;&quot;&quot;&#10;    reader = PdfReader(file_path)&#10;    text = &quot;&quot;&#10;    for page in reader.pages:&#10;        page_text = page.extract_text() or &quot;&quot;&#10;        text += page_text&#10;    return text&#10;&#10;def load_papers(directory: str) -&gt; List[str]:&#10;    &quot;&quot;&quot;Load all .txt and .pdf files from a directory and return their contents.&quot;&quot;&quot;&#10;    papers = []&#10;    try:&#10;        for filename in os.listdir(directory):&#10;            file_path = os.path.join(directory, filename)&#10;            if filename.endswith(&quot;.txt&quot;):&#10;                try:&#10;                    papers.append(load_text_file(file_path))&#10;                except Exception as e:&#10;                    print(f&quot;Error reading text file {filename}: {e}&quot;)&#10;            elif filename.endswith(&quot;.pdf&quot;):&#10;                try:&#10;                    papers.append(load_pdf_file(file_path))&#10;                except Exception as e:&#10;                    print(f&quot;Error reading PDF {filename}: {e}&quot;)&#10;        print(f&quot;Loaded {len(papers)} papers&quot;)&#10;        return papers&#10;    except Exception as e:&#10;        print(f&quot;Error loading papers: {e}&quot;)&#10;        return []&#10;&#10;# ------------------ Answer Checking Utilities ------------------&#10;&#10;def load_json_file(filepath: str) -&gt; Any:&#10;    &quot;&quot;&quot;Load and return JSON data from a file.&quot;&quot;&quot;&#10;    with open(filepath, 'r') as f:&#10;        return json.load(f)&#10;&#10;def compare_answers(generated_paper: List[Dict], submitted_answers: Dict) -&gt; Tuple[int, List[Dict]]:&#10;    &quot;&quot;&quot;Compare submitted answers with correct answers and return score and detailed results.&quot;&quot;&quot;&#10;    score = 0&#10;    results = []&#10;    for question in generated_paper:&#10;        q_num = question.get('question_number')&#10;        correct_answer = question.get('answer')&#10;        submitted_answer = submitted_answers.get(str(q_num)) or submitted_answers.get(q_num)&#10;        is_correct = (str(submitted_answer).strip().lower() == str(correct_answer).strip().lower())&#10;        results.append({&#10;            'question_number': q_num,&#10;            'correct_answer': correct_answer,&#10;            'submitted_answer': submitted_answer,&#10;            'is_correct': is_correct&#10;        })&#10;        if is_correct:&#10;            score += 1&#10;    return score, results&#10;&#10;def print_results(generated_paper: List[Dict], score: int, results: List[Dict]):&#10;    &quot;&quot;&quot;Print summary and detailed results of answer comparison.&quot;&quot;&quot;&#10;    print(f&quot;Total Questions: {len(generated_paper)}&quot;)&#10;    print(f&quot;Correct Answers: {score}&quot;)&#10;    print(&quot;Detailed Results:&quot;)&#10;    for res in results:&#10;        print(&#10;            f&quot;Q{res['question_number']}: Submitted: {res['submitted_answer']} | Correct: {res['correct_answer']} | {'Correct' if res['is_correct'] else 'Incorrect'}&quot;&#10;        )&#10;&#10;def check_online_paper(generated_paper_filepath: str, submitted_answer_sheet_filepath: str, exam_name: str):&#10;    &quot;&quot;&quot;&#10;    Compares the submitted answers with the generated paper and prints the result for each question.&#10;    Returns a dict containing score and detailed results.&#10;    &quot;&quot;&quot;&#10;    if not os.path.exists(generated_paper_filepath):&#10;        print(f&quot;File {generated_paper_filepath} does not exist.&quot;)&#10;        return None&#10;    if not generated_paper_filepath.endswith(&quot;.json&quot;):&#10;        print(&quot;Generated paper file is not a JSON file.&quot;)&#10;        return None&#10;&#10;    submitted_answers = load_json_file(submitted_answer_sheet_filepath)&#10;    generated_paper = load_json_file(generated_paper_filepath)&#10;    score, results = compare_answers(generated_paper, submitted_answers)&#10;    print_results(generated_paper, score, results)&#10;    return {&#10;        'score': score,&#10;        'total': len(generated_paper),&#10;        'results': results&#10;    }&#10;&#10;# ------------------ Text Cleaning Utilities ------------------&#10;&#10;def clean_text(text: str) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    Cleans and replaces special characters in the text for better readability.&#10;    &quot;&quot;&quot;&#10;    replacements = {&#10;        '√': 'sqrt', '±': '+/-', '°': ' degrees', '×': 'x', '÷': '/',&#10;        '≠': '!=', '≤': '&lt;=', '≥': '&gt;=', '∞': 'infinity', 'π': 'pi',&#10;        'μ': 'u', 'Δ': 'delta', 'α': 'alpha', 'β': 'beta', 'γ': 'gamma'&#10;    }&#10;    for old, new in replacements.items():&#10;        text = text.replace(old, new)&#10;    text = re.sub(r'[^\x00-\x7F]+', '', text)&#10;    return text&#10;&#10;# ------------------ PDF Generation Utilities ------------------&#10;&#10;def group_questions_by_subject(data: List[Dict]) -&gt; Dict[str, List[Dict]]:&#10;    &quot;&quot;&quot;Group questions by subject.&quot;&quot;&quot;&#10;    subjects = {}&#10;    for item in data:&#10;        subject = item.get('subject', 'General')&#10;        subjects.setdefault(subject, []).append(item)&#10;    return subjects&#10;&#10;def generate_question_pdf(subjects: Dict[str, List[Dict]], filepath: str) -&gt; str:&#10;    &quot;&quot;&quot;Generate a PDF for the question paper.&quot;&quot;&quot;&#10;    question_pdf = FPDF()&#10;    question_pdf.add_page()&#10;    question_pdf.set_font(&quot;Arial&quot;, 'B', 16)&#10;    question_pdf.cell(0, 12, txt=&quot;Question Paper&quot;, ln=True, align='C')&#10;    question_pdf.ln(8)&#10;    for subject, questions in subjects.items():&#10;        question_pdf.set_font(&quot;Arial&quot;, 'B', 14)&#10;        question_pdf.cell(0, 10, txt=f&quot;{subject} Section&quot;, ln=True)&#10;        question_pdf.set_font(&quot;Arial&quot;, size=12)&#10;        question_pdf.ln(2)&#10;        for item in questions:&#10;            question_text = clean_text(item['question'])&#10;            question_pdf.multi_cell(0, 10, f&quot;Q{item['question_number']}: {question_text}&quot;)&#10;            if 'options' in item and item['options']:&#10;                for idx, opt in enumerate(item['options']):&#10;                    option_text = clean_text(opt)&#10;                    question_pdf.multi_cell(0, 8, f&quot;    {chr(65 + idx)}. {option_text}&quot;)&#10;            question_pdf.ln(4)&#10;        question_pdf.ln(6)&#10;    question_pdf_path = filepath.replace(&quot;.json&quot;, &quot;_questions.pdf&quot;)&#10;    question_pdf.output(question_pdf_path)&#10;    return question_pdf_path&#10;&#10;def generate_answer_pdf(subjects: Dict[str, List[Dict]], filepath: str) -&gt; str:&#10;    &quot;&quot;&quot;Generate a PDF for the answer sheet.&quot;&quot;&quot;&#10;    answer_pdf = FPDF()&#10;    answer_pdf.add_page()&#10;    answer_pdf.set_font(&quot;Arial&quot;, 'B', 16)&#10;    answer_pdf.cell(0, 12, txt=&quot;Answer Sheet&quot;, ln=True, align='C')&#10;    answer_pdf.ln(8)&#10;    for subject, questions in subjects.items():&#10;        answer_pdf.set_font(&quot;Arial&quot;, 'B', 14)&#10;        answer_pdf.cell(0, 10, txt=f&quot;{subject} Section&quot;, ln=True)&#10;        answer_pdf.set_font(&quot;Arial&quot;, size=12)&#10;        answer_pdf.ln(2)&#10;        for item in questions:&#10;            answer_text = clean_text(str(item['answer']))&#10;            answer_pdf.cell(0, 10, f&quot;Q{item['question_number']}: {answer_text}&quot;, ln=True)&#10;        answer_pdf.ln(6)&#10;    answer_pdf_path = filepath.replace(&quot;.json&quot;, &quot;_answers.pdf&quot;)&#10;    answer_pdf.output(answer_pdf_path)&#10;    return answer_pdf_path&#10;&#10;def extract_and_convert(filepath: str) -&gt; Tuple[str, str]:&#10;    &quot;&quot;&quot;&#10;    Extracts questions and answers from the JSON file and generates PDFs for the question paper and answer sheet.&#10;    Returns paths to the generated PDFs.&#10;    &quot;&quot;&quot;&#10;    if not filepath.endswith(&quot;.json&quot;):&#10;        return None, None&#10;    data = load_json_file(filepath)&#10;    subjects = group_questions_by_subject(data)&#10;    question_pdf_path = generate_question_pdf(subjects, filepath)&#10;    answer_pdf_path = generate_answer_pdf(subjects, filepath)&#10;    return question_pdf_path, answer_pdf_path&#10;&#10;# ...end of file...&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>