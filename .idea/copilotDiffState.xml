<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/generate_paper.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/generate_paper.py" />
              <option name="originalContent" value="import os&#10;import time&#10;from typing import List&#10;from google import genai&#10;from pydantic import BaseModel&#10;&#10;from fpdf import FPDF&#10;import json&#10;import re&#10;&#10;# Model name for Gemini API&#10;model = &quot;gemini-2.5-pro&quot;&#10;&#10;# Context string for JEE Mains paper generation&#10;jee_mains_context = &quot;&quot;&quot;&#10;The JEE Mains paper typically consists of three sections: Physics, Chemistry, and Mathematics. Each section contains multiple-choice questions (MCQs) and numerical value-based questions. The exam is conducted in a computer-based format.&#10;I want you to generate a paper for JEE Mains with the following specifications:\n&#10;I want you to generate a full length jee mains question paper\n&#10;It should have a total of 90 questions, with 30 questions from each subject (Physics, Chemistry, Mathematics). Candidates can attempt a maximum of 75 questions. The questions should be a mix of MCQs and numerical value-based questions.\n&#10;- Total Questions: 90 (30 per subject; candidates can attempt 75)&#10;- Question Types:&#10;- MCQs (with four options, one correct)  &#10;- Numerical value-based questions (no options, answer is a number)&#10;&quot;&quot;&quot;&#10;&#10;# Context string for JEE Advanced paper generation&#10;jee_advanced_context = &quot;&quot;&quot;&#10;The JEE Advanced paper is designed for admission to the prestigious Indian Institutes of Technology (IITs). It consists of two papers, each with three sections: Physics, Chemistry, and Mathematics. The questions include multiple-choice questions (MCQs), numerical value-based questions, and matching-type questions. The exam is conducted in a computer-based format.&#10;I want you to generate a paper for JEE Advanced with the following specifications:\n&#10;I want you to generate a full length JEE Advanced question paper\n&#10;Each paper should have a total of 54 questions, with 18 questions from each subject (Physics, Chemistry, Mathematics). The questions should be a mix of MCQs, numerical value-based, and matching-type questions.\n&#10;- Total Questions per paper: 54 (18 per subject)&#10;    - Question Types:&#10;        - MCQs (with four options, one or more correct)&#10;        - Numerical value-based questions (no options, answer is a number)&#10;        - Matching-type questions (match the following)&#10;&quot;&quot;&quot;&#10;&#10;# Context string for NEET UG paper generation&#10;neet_ug_context = &quot;&quot;&quot;&#10;The NEET (National Eligibility cum Entrance Test) paper is for admission to medical courses in India. It consists of four sections: Physics, Chemistry, Botany, and Zoology. Each section contains multiple-choice questions (MCQs) with four options and one correct answer. The exam is conducted in a pen-and-paper format.&#10;I want you to generate a paper for NEET with the following specifications:\n&#10;I want you to generate a full length NEET question paper\n&#10;It should have a total of 200 questions, with 50 questions from each subject (Physics, Chemistry, Botany, Zoology). Candidates can attempt a maximum of 180 questions. All questions should be MCQs.\n&#10;- Total Questions: 200 (50 per subject; candidates can attempt 180)&#10;    - Question Types:&#10;        - MCQs (with four options, one correct)&#10;&quot;&quot;&quot;&#10;&#10;# Pydantic model for MCQ format questions&#10;class PaperFormatForMCQ(BaseModel):&#10;    question_number: int&#10;    question: str&#10;    options: List[str]&#10;    answer: str&#10;&#10;# Pydantic model for subjective format questions&#10;class PaperFormatForSubjective(BaseModel):&#10;    question_number: int&#10;    question: str&#10;    answer: str&#10;&#10;# Read API key from file&#10;with open(&quot;apikey.txt&quot;,'r') as f:&#10;    api_key = f.read().strip()&#10;&#10;# Initialize Gemini client&#10;client = genai.Client(api_key=api_key)&#10;&#10;def generate_paper(name_of_the_exam: str, difficulty_level: str, format_of_the_exam: str):&#10;    &quot;&quot;&quot;&#10;    Generates a paper based on the provided parameters.&#10;&#10;    Args:&#10;        name_of_the_exam (str): Name of the exam.&#10;        difficulty_level (str): Difficulty level of the exam.&#10;        format_of_the_exam (str): Format of the exam.&#10;&#10;    Returns:&#10;        str: Path to the generated PDF file.&#10;    &quot;&quot;&quot;&#10;    response = None&#10;    # Generate paper for JEE Mains&#10;    if name_of_the_exam.upper() == &quot;JEE_MAINS&quot;:&#10;        response = client.models.generate_content(&#10;            model= model,&#10;            contents=&quot;You are an expert in creating high-quality exam papers for competitive exams like &quot;&#10;                     f&quot;{name_of_the_exam.upper()}.\n&quot;&#10;                     f&quot;Generate a paper with {difficulty_level} difficulty level and format {format_of_the_exam}.\n&quot;&#10;                     f&quot;{jee_mains_context}&quot;,&#10;            config={&#10;                &quot;response_mime_type&quot;: &quot;application/json&quot;,&#10;                &quot;response_schema&quot;: list[PaperFormatForMCQ],&#10;            },&#10;        )&#10;    # Generate paper for JEE Advanced&#10;    elif name_of_the_exam.upper() == &quot;JEE_ADVANCED&quot;:&#10;        response = client.models.generate_content(&#10;            model= model,&#10;            contents=&quot;You are an expert in creating high-quality exam papers for competitive exams like &quot;&#10;                     f&quot;{name_of_the_exam.upper()}.\n&quot;&#10;                     f&quot;Generate a paper with {difficulty_level} difficulty level and format {format_of_the_exam}.\n&quot;&#10;                     f&quot;{jee_advanced_context}&quot;,&#10;            config={&#10;                &quot;response_mime_type&quot;: &quot;application/json&quot;,&#10;                &quot;response_schema&quot;: list[PaperFormatForMCQ],&#10;            },&#10;        )&#10;    # Generate paper for NEET UG&#10;    elif name_of_the_exam.upper() == &quot;NEET_UG&quot;:&#10;        response = client.models.generate_content(&#10;            model= model,&#10;            contents=&quot;You are an expert in creating high-quality exam papers for competitive exams like &quot;&#10;                     f&quot;{name_of_the_exam.upper()}.\n&quot;&#10;                     f&quot;Generate a paper with {difficulty_level} difficulty level and format {format_of_the_exam}.\n&quot;&#10;                     f&quot;{neet_ug_context}&quot;,&#10;            config={&#10;                &quot;response_mime_type&quot;: &quot;application/json&quot;,&#10;                &quot;response_schema&quot;: list[PaperFormatForMCQ],&#10;            },&#10;        )&#10;&#10;    def clean_text(text):&#10;        &quot;&quot;&quot;&#10;        Cleans and replaces special characters in the text for better readability.&#10;&#10;        Args:&#10;            text (str): Input text.&#10;&#10;        Returns:&#10;            str: Cleaned text.&#10;        &quot;&quot;&quot;&#10;        replacements = {&#10;            '√': 'sqrt', '±': '+/-', '°': ' degrees', '×': 'x', '÷': '/',&#10;            '≠': '!=', '≤': '&lt;=', '≥': '&gt;=', '∞': 'infinity', 'π': 'pi',&#10;            'μ': 'u', 'Δ': 'delta', 'α': 'alpha', 'β': 'beta', 'γ': 'gamma'&#10;        }&#10;        for old, new in replacements.items():&#10;            text = text.replace(old, new)&#10;        # Remove non-ASCII characters&#10;        text = re.sub(r'[^\x00-\x7F]+', '', text)&#10;        return text&#10;&#10;    def extract_and_convert(filepath):&#10;        &quot;&quot;&quot;&#10;        Extracts questions and answers from the JSON file and generates PDFs for the question paper and answer sheet.&#10;&#10;        Args:&#10;            filepath (str): Path to the JSON file.&#10;&#10;        Returns:&#10;            tuple: Paths to the generated question paper and answer sheet PDFs.&#10;        &quot;&quot;&quot;&#10;        if not filepath.endswith(&quot;.json&quot;):&#10;            return None, None&#10;&#10;        # Load questions from JSON file&#10;        with open(filepath, 'r') as f:&#10;            data = json.load(f)&#10;&#10;        # Group questions by subject if available&#10;        subjects = {}&#10;        for item in data:&#10;            subject = item.get('subject', 'General')&#10;            subjects.setdefault(subject, []).append(item)&#10;&#10;        # Generate Question Paper PDF&#10;        question_pdf = FPDF()&#10;        question_pdf.add_page()&#10;        question_pdf.set_font(&quot;Arial&quot;, 'B', 16)&#10;        question_pdf.cell(0, 12, txt=&quot;Question Paper&quot;, ln=True, align='C')&#10;        question_pdf.ln(8)&#10;&#10;        # Add questions to PDF, grouped by subject&#10;        for subject, questions in subjects.items():&#10;            question_pdf.set_font(&quot;Arial&quot;, 'B', 14)&#10;            question_pdf.cell(0, 10, txt=f&quot;{subject} Section&quot;, ln=True)&#10;            question_pdf.set_font(&quot;Arial&quot;, size=12)&#10;            question_pdf.ln(2)&#10;            for item in questions:&#10;                question_text = clean_text(item['question'])&#10;                question_pdf.multi_cell(0, 10, f&quot;Q{item['question_number']}: {question_text}&quot;)&#10;                if 'options' in item and item['options']:&#10;                    for idx, opt in enumerate(item['options']):&#10;                        option_text = clean_text(opt)&#10;                        question_pdf.multi_cell(0, 8, f&quot;    {chr(65 + idx)}. {option_text}&quot;)&#10;                question_pdf.ln(4)&#10;            question_pdf.ln(6)&#10;&#10;        question_pdf_path = filepath.replace(&quot;.json&quot;, &quot;_questions.pdf&quot;)&#10;        question_pdf.output(question_pdf_path)&#10;&#10;        # Generate Answer Sheet PDF&#10;        answer_pdf = FPDF()&#10;        answer_pdf.add_page()&#10;        answer_pdf.set_font(&quot;Arial&quot;, 'B', 16)&#10;        answer_pdf.cell(0, 12, txt=&quot;Answer Sheet&quot;, ln=True, align='C')&#10;        answer_pdf.ln(8)&#10;&#10;        # Add answers to PDF, grouped by subject&#10;        for subject, questions in subjects.items():&#10;            answer_pdf.set_font(&quot;Arial&quot;, 'B', 14)&#10;            answer_pdf.cell(0, 10, txt=f&quot;{subject} Section&quot;, ln=True)&#10;            answer_pdf.set_font(&quot;Arial&quot;, size=12)&#10;            answer_pdf.ln(2)&#10;            for item in questions:&#10;                answer_text = clean_text(str(item['answer']))&#10;                answer_pdf.cell(0, 10, f&quot;Q{item['question_number']}: {answer_text}&quot;, ln=True)&#10;            answer_pdf.ln(6)&#10;&#10;        answer_pdf_path = filepath.replace(&quot;.json&quot;, &quot;_answers.pdf&quot;)&#10;        answer_pdf.output(answer_pdf_path)&#10;&#10;        return question_pdf_path, answer_pdf_path&#10;&#10;    &#10;    # Create output directory if it doesn't exist&#10;    output_dir = &quot;GENERATED_PAPERS&quot;&#10;    os.makedirs(output_dir, exist_ok=True)&#10;    filename = f&quot;{name_of_the_exam}_{difficulty_level}_{format_of_the_exam}.json&quot;&#10;    filepath = os.path.join(output_dir, filename)&#10;&#10;    # Write generated paper to JSON file&#10;    with open(filepath, 'w') as f:&#10;        text = response.text&#10;        f.write(text)&#10;    return filepath&#10;&#10;def check_online_paper(generated_paper_filepath: str, submitted_answer_sheet_filepath: str, exam_name: str):&#10;    &quot;&quot;&quot;&#10;    Compares the submitted answers with the generated paper and prints the result for each question.&#10;&#10;    Args:&#10;        generated_paper_filepath (str): Path to the generated paper JSON file.&#10;        submitted_answer_sheet_filepath (str): Path to the submitted answer sheet JSON file.&#10;&#10;    Returns:&#10;        dict: Dictionary containing score and detailed results.&#10;&#10;    Expected format for submitted_answer_sheet_filepath (JSON):&#10;        {&#10;            &quot;1&quot;: &quot;A&quot;,&#10;            &quot;2&quot;: &quot;B&quot;,&#10;            &quot;3&quot;: &quot;42&quot;,&#10;            ...&#10;        }&#10;    Keys can be either strings or integers representing question_number.&#10;    Values are the submitted answers (option letter or numerical value).&#10;    &quot;&quot;&quot;&#10;    # Check if generated paper file exists&#10;    if not os.path.exists(generated_paper_filepath):&#10;        print(f&quot;File {generated_paper_filepath} does not exist.&quot;)&#10;        return None&#10;&#10;    # Check if file is a JSON file&#10;    if not generated_paper_filepath.endswith(&quot;.json&quot;):&#10;        print(&quot;Generated paper file is not a JSON file.&quot;)&#10;        return None&#10;&#10;    # Load submitted answers&#10;    with open(submitted_answer_sheet_filepath, 'r') as f:&#10;        submitted_answers = json.load(f)&#10;&#10;    # Load generated paper&#10;    with open(generated_paper_filepath, 'r') as f:&#10;        generated_paper = json.load(f)&#10;&#10;    # Initialize score and results&#10;    score = 0&#10;    results = []&#10;&#10;    # Compare answers for each question&#10;    for question in generated_paper:&#10;        q_num = question.get('question_number')&#10;        correct_answer = question.get('answer')&#10;        submitted_answer = submitted_answers.get(str(q_num)) or submitted_answers.get(q_num)&#10;        # Check if answer matches&#10;        is_correct = (str(submitted_answer).strip().lower() == str(correct_answer).strip().lower())&#10;        results.append({&#10;            'question_number': q_num,&#10;            'correct_answer': correct_answer,&#10;            'submitted_answer': submitted_answer,&#10;            'is_correct': is_correct&#10;        })&#10;        if is_correct:&#10;            score += 1&#10;&#10;    # Print summary&#10;    print(f&quot;Total Questions: {len(generated_paper)}&quot;)&#10;    print(f&quot;Correct Answers: {score}&quot;)&#10;    print(&quot;Detailed Results:&quot;)&#10;    for res in results:&#10;        print(f&quot;Q{res['question_number']}: Submitted: {res['submitted_answer']} | Correct: {res['correct_answer']} | {'Correct' if res['is_correct'] else 'Incorrect'}&quot;)&#10;&#10;    return {&#10;        'score': score,&#10;        'total': len(generated_paper),&#10;        'results': results&#10;    }&#10;" />
              <option name="updatedContent" value="import os&#10;import time&#10;from typing import List&#10;from google import genai&#10;from pydantic import BaseModel&#10;&#10;from fpdf import FPDF&#10;import json&#10;import re&#10;&#10;# Model name for Gemini API&#10;model = &quot;gemini-2.5-pro&quot;&#10;&#10;# Context string for JEE Mains paper generation&#10;jee_mains_context = &quot;&quot;&quot;&#10;The JEE Mains paper typically consists of three sections: Physics, Chemistry, and Mathematics. Each section contains multiple-choice questions (MCQs) and numerical value-based questions. The exam is conducted in a computer-based format.&#10;I want you to generate a paper for JEE Mains with the following specifications:\n&#10;I want you to generate a full length jee mains question paper\n&#10;It should have a total of 90 questions, with 30 questions from each subject (Physics, Chemistry, Mathematics). Candidates can attempt a maximum of 75 questions. The questions should be a mix of MCQs and numerical value-based questions.\n&#10;- Total Questions: 90 (30 per subject; candidates can attempt 75)&#10;- Question Types:&#10;- MCQs (with four options, one correct)  &#10;- Numerical value-based questions (no options, answer is a number)&#10;&quot;&quot;&quot;&#10;&#10;# Context string for JEE Advanced paper generation&#10;jee_advanced_context = &quot;&quot;&quot;&#10;The JEE Advanced paper is designed for admission to the prestigious Indian Institutes of Technology (IITs). It consists of two papers, each with three sections: Physics, Chemistry, and Mathematics. The questions include multiple-choice questions (MCQs), numerical value-based questions, and matching-type questions. The exam is conducted in a computer-based format.&#10;I want you to generate a paper for JEE Advanced with the following specifications:\n&#10;I want you to generate a full length JEE Advanced question paper\n&#10;Each paper should have a total of 54 questions, with 18 questions from each subject (Physics, Chemistry, Mathematics). The questions should be a mix of MCQs, numerical value-based, and matching-type questions.\n&#10;- Total Questions per paper: 54 (18 per subject)&#10;    - Question Types:&#10;        - MCQs (with four options, one or more correct)&#10;        - Numerical value-based questions (no options, answer is a number)&#10;        - Matching-type questions (match the following)&#10;&quot;&quot;&quot;&#10;&#10;# Context string for NEET UG paper generation&#10;neet_ug_context = &quot;&quot;&quot;&#10;The NEET (National Eligibility cum Entrance Test) paper is for admission to medical courses in India. It consists of four sections: Physics, Chemistry, Botany, and Zoology. Each section contains multiple-choice questions (MCQs) with four options and one correct answer. The exam is conducted in a pen-and-paper format.&#10;I want you to generate a paper for NEET with the following specifications:\n&#10;I want you to generate a full length NEET question paper\n&#10;It should have a total of 200 questions, with 50 questions from each subject (Physics, Chemistry, Botany, Zoology). Candidates can attempt a maximum of 180 questions. All questions should be MCQs.\n&#10;- Total Questions: 200 (50 per subject; candidates can attempt 180)&#10;    - Question Types:&#10;        - MCQs (with four options, one correct)&#10;&quot;&quot;&quot;&#10;&#10;# Pydantic model for MCQ format questions&#10;class PaperFormatForMCQ(BaseModel):&#10;    question_number: int&#10;    question: str&#10;    options: List[str]&#10;    answer: str&#10;&#10;# Pydantic model for subjective format questions&#10;class PaperFormatForSubjective(BaseModel):&#10;    question_number: int&#10;    question: str&#10;    answer: str&#10;&#10;# Read API key from file&#10;with open(&quot;apikey.txt&quot;,'r') as f:&#10;    api_key = f.read().strip()&#10;&#10;# Initialize Gemini client&#10;client = genai.Client(api_key=api_key)&#10;&#10;def generate_paper(name_of_the_exam: str, difficulty_level: str, format_of_the_exam: str):&#10;    &quot;&quot;&quot;&#10;    Generates a paper based on the provided parameters.&#10;&#10;    Args:&#10;        name_of_the_exam (str): Name of the exam.&#10;        difficulty_level (str): Difficulty level of the exam.&#10;        format_of_the_exam (str): Format of the exam.&#10;&#10;    Returns:&#10;        str: Path to the generated PDF file.&#10;    &quot;&quot;&quot;&#10;    response = None&#10;    # Generate paper for JEE Mains&#10;    if name_of_the_exam.upper() == &quot;JEE_MAINS&quot;:&#10;        response = client.models.generate_content(&#10;            model= model,&#10;            contents=&quot;You are an expert in creating high-quality exam papers for competitive exams like &quot;&#10;                     f&quot;{name_of_the_exam.upper()}.\n&quot;&#10;                     f&quot;Generate a paper with {difficulty_level} difficulty level and format {format_of_the_exam}.\n&quot;&#10;                     f&quot;{jee_mains_context}&quot;,&#10;            config={&#10;                &quot;response_mime_type&quot;: &quot;application/json&quot;,&#10;                &quot;response_schema&quot;: list[PaperFormatForMCQ],&#10;            },&#10;        )&#10;    # Generate paper for JEE Advanced&#10;    elif name_of_the_exam.upper() == &quot;JEE_ADVANCED&quot;:&#10;        response = client.models.generate_content(&#10;            model= model,&#10;            contents=&quot;You are an expert in creating high-quality exam papers for competitive exams like &quot;&#10;                     f&quot;{name_of_the_exam.upper()}.\n&quot;&#10;                     f&quot;Generate a paper with {difficulty_level} difficulty level and format {format_of_the_exam}.\n&quot;&#10;                     f&quot;{jee_advanced_context}&quot;,&#10;            config={&#10;                &quot;response_mime_type&quot;: &quot;application/json&quot;,&#10;                &quot;response_schema&quot;: list[PaperFormatForMCQ],&#10;            },&#10;        )&#10;    # Generate paper for NEET UG&#10;    elif name_of_the_exam.upper() == &quot;NEET_UG&quot;:&#10;        response = client.models.generate_content(&#10;            model= model,&#10;            contents=&quot;You are an expert in creating high-quality exam papers for competitive exams like &quot;&#10;                     f&quot;{name_of_the_exam.upper()}.\n&quot;&#10;                     f&quot;Generate a paper with {difficulty_level} difficulty level and format {format_of_the_exam}.\n&quot;&#10;                     f&quot;{neet_ug_context}&quot;,&#10;            config={&#10;                &quot;response_mime_type&quot;: &quot;application/json&quot;,&#10;                &quot;response_schema&quot;: list[PaperFormatForMCQ],&#10;            },&#10;        )&#10;&#10;    def clean_text(text):&#10;        &quot;&quot;&quot;&#10;        Cleans and replaces special characters in the text for better readability.&#10;&#10;        Args:&#10;            text (str): Input text.&#10;&#10;        Returns:&#10;            str: Cleaned text.&#10;        &quot;&quot;&quot;&#10;        replacements = {&#10;            '√': 'sqrt', '±': '+/-', '°': ' degrees', '×': 'x', '÷': '/',&#10;            '≠': '!=', '≤': '&lt;=', '≥': '&gt;=', '∞': 'infinity', 'π': 'pi',&#10;            'μ': 'u', 'Δ': 'delta', 'α': 'alpha', 'β': 'beta', 'γ': 'gamma'&#10;        }&#10;        for old, new in replacements.items():&#10;            text = text.replace(old, new)&#10;        # Remove non-ASCII characters&#10;        text = re.sub(r'[^\x00-\x7F]+', '', text)&#10;        return text&#10;&#10;    def extract_and_convert(filepath):&#10;        &quot;&quot;&quot;&#10;        Extracts questions and answers from the JSON file and generates PDFs for the question paper and answer sheet.&#10;&#10;        Args:&#10;            filepath (str): Path to the JSON file.&#10;&#10;        Returns:&#10;            tuple: Paths to the generated question paper and answer sheet PDFs.&#10;        &quot;&quot;&quot;&#10;        if not filepath.endswith(&quot;.json&quot;):&#10;            return None, None&#10;&#10;        # Load questions from JSON file&#10;        with open(filepath, 'r') as f:&#10;            data = json.load(f)&#10;&#10;        # Group questions by subject if available&#10;        subjects = {}&#10;        for item in data:&#10;            subject = item.get('subject', 'General')&#10;            subjects.setdefault(subject, []).append(item)&#10;&#10;        # Generate Question Paper PDF&#10;        question_pdf = FPDF()&#10;        question_pdf.add_page()&#10;        question_pdf.set_font(&quot;Arial&quot;, 'B', 16)&#10;        question_pdf.cell(0, 12, txt=&quot;Question Paper&quot;, ln=True, align='C')&#10;        question_pdf.ln(8)&#10;&#10;        # Add questions to PDF, grouped by subject&#10;        for subject, questions in subjects.items():&#10;            question_pdf.set_font(&quot;Arial&quot;, 'B', 14)&#10;            question_pdf.cell(0, 10, txt=f&quot;{subject} Section&quot;, ln=True)&#10;            question_pdf.set_font(&quot;Arial&quot;, size=12)&#10;            question_pdf.ln(2)&#10;            for item in questions:&#10;                question_text = clean_text(item['question'])&#10;                question_pdf.multi_cell(0, 10, f&quot;Q{item['question_number']}: {question_text}&quot;)&#10;                if 'options' in item and item['options']:&#10;                    for idx, opt in enumerate(item['options']):&#10;                        option_text = clean_text(opt)&#10;                        question_pdf.multi_cell(0, 8, f&quot;    {chr(65 + idx)}. {option_text}&quot;)&#10;                question_pdf.ln(4)&#10;            question_pdf.ln(6)&#10;&#10;        question_pdf_path = filepath.replace(&quot;.json&quot;, &quot;_questions.pdf&quot;)&#10;        question_pdf.output(question_pdf_path)&#10;&#10;        # Generate Answer Sheet PDF&#10;        answer_pdf = FPDF()&#10;        answer_pdf.add_page()&#10;        answer_pdf.set_font(&quot;Arial&quot;, 'B', 16)&#10;        answer_pdf.cell(0, 12, txt=&quot;Answer Sheet&quot;, ln=True, align='C')&#10;        answer_pdf.ln(8)&#10;&#10;        # Add answers to PDF, grouped by subject&#10;        for subject, questions in subjects.items():&#10;            answer_pdf.set_font(&quot;Arial&quot;, 'B', 14)&#10;            answer_pdf.cell(0, 10, txt=f&quot;{subject} Section&quot;, ln=True)&#10;            answer_pdf.set_font(&quot;Arial&quot;, size=12)&#10;            answer_pdf.ln(2)&#10;            for item in questions:&#10;                answer_text = clean_text(str(item['answer']))&#10;                answer_pdf.cell(0, 10, f&quot;Q{item['question_number']}: {answer_text}&quot;, ln=True)&#10;            answer_pdf.ln(6)&#10;&#10;        answer_pdf_path = filepath.replace(&quot;.json&quot;, &quot;_answers.pdf&quot;)&#10;        answer_pdf.output(answer_pdf_path)&#10;&#10;        return question_pdf_path, answer_pdf_path&#10;&#10;    &#10;    # Create output directory if it doesn't exist&#10;    output_dir = &quot;GENERATED_PAPERS&quot;&#10;    os.makedirs(output_dir, exist_ok=True)&#10;    filename = f&quot;{name_of_the_exam}_{difficulty_level}_{format_of_the_exam}.json&quot;&#10;    filepath = os.path.join(output_dir, filename)&#10;&#10;    # Write generated paper to JSON file&#10;    with open(filepath, 'w') as f:&#10;        text = response.text&#10;        f.write(text)&#10;    return filepath&#10;&#10;def check_online_paper(generated_paper_filepath: str, submitted_answer_sheet_filepath: str, exam_name: str):&#10;    &quot;&quot;&quot;&#10;    Compares the submitted answers with the generated paper and prints the result for each question.&#10;    Handles different exam schemas and scoring for NEET, JEE Mains, and JEE Advanced.&#10;&#10;    Args:&#10;        generated_paper_filepath (str): Path to the generated paper JSON file.&#10;        submitted_answer_sheet_filepath (str): Path to the submitted answer sheet JSON file.&#10;        exam_name (str): Name of the exam (&quot;NEET_UG&quot;, &quot;JEE_MAINS&quot;, &quot;JEE_ADVANCED&quot;).&#10;&#10;    Returns:&#10;        dict: Dictionary containing score and detailed results.&#10;&#10;    Expected format for submitted_answer_sheet_filepath (JSON):&#10;        {&#10;            &quot;1&quot;: &quot;A&quot;,&#10;            &quot;2&quot;: &quot;B&quot;,&#10;            &quot;3&quot;: &quot;42&quot;,&#10;            ...&#10;        }&#10;    Keys can be either strings or integers representing question_number.&#10;    Values are the submitted answers (option letter or numerical value).&#10;    &quot;&quot;&quot;&#10;    # Check if generated paper file exists&#10;    if not os.path.exists(generated_paper_filepath):&#10;        print(f&quot;File {generated_paper_filepath} does not exist.&quot;)&#10;        return None&#10;&#10;    # Check if file is a JSON file&#10;    if not generated_paper_filepath.endswith(&quot;.json&quot;):&#10;        print(&quot;Generated paper file is not a JSON file.&quot;)&#10;        return None&#10;&#10;    # Load submitted answers&#10;    with open(submitted_answer_sheet_filepath, 'r') as f:&#10;        submitted_answers = json.load(f)&#10;&#10;    # Load generated paper&#10;    with open(generated_paper_filepath, 'r') as f:&#10;        generated_paper = json.load(f)&#10;&#10;    # Set scoring rules based on exam&#10;    exam_name = exam_name.upper()&#10;    if exam_name == &quot;NEET_UG&quot;:&#10;        # NEET: +4 for correct, -1 for incorrect, 0 for not attempted&#10;        marks_correct = 4&#10;        marks_incorrect = -1&#10;        marks_unattempted = 0&#10;    elif exam_name == &quot;JEE_MAINS&quot;:&#10;        # JEE Mains: +4 for correct, -1 for incorrect (MCQ), 0 for not attempted/numerical&#10;        marks_correct = 4&#10;        marks_incorrect = -1&#10;        marks_unattempted = 0&#10;    elif exam_name == &quot;JEE_ADVANCED&quot;:&#10;        # JEE Advanced: scoring varies, but for simplicity:&#10;        # MCQ (single correct): +3, -1; MCQ (multiple correct): +4, -2; Numerical: +3, 0; Matching: +4, 0&#10;        # We'll infer type from question if possible, else default to +3/-1&#10;        pass  # Will handle per question below&#10;    else:&#10;        print(&quot;Unknown exam name. Defaulting to +1 for correct, 0 for incorrect.&quot;)&#10;        marks_correct = 1&#10;        marks_incorrect = 0&#10;        marks_unattempted = 0&#10;&#10;    total_score = 0&#10;    results = []&#10;&#10;    for question in generated_paper:&#10;        q_num = question.get('question_number')&#10;        correct_answer = question.get('answer')&#10;        submitted_answer = submitted_answers.get(str(q_num)) or submitted_answers.get(q_num)&#10;        question_type = None&#10;&#10;        # Try to infer question type for JEE Advanced&#10;        if exam_name == &quot;JEE_ADVANCED&quot;:&#10;            if 'options' in question and isinstance(question['options'], list):&#10;                if isinstance(correct_answer, list) and len(correct_answer) &gt; 1:&#10;                    question_type = &quot;MCQ_MULTIPLE&quot;&#10;                    marks_correct = 4&#10;                    marks_incorrect = -2&#10;                else:&#10;                    question_type = &quot;MCQ_SINGLE&quot;&#10;                    marks_correct = 3&#10;                    marks_incorrect = -1&#10;            elif 'match' in question or 'matching' in question.get('question', '').lower():&#10;                question_type = &quot;MATCHING&quot;&#10;                marks_correct = 4&#10;                marks_incorrect = 0&#10;            else:&#10;                question_type = &quot;NUMERICAL&quot;&#10;                marks_correct = 3&#10;                marks_incorrect = 0&#10;&#10;        # Determine correctness&#10;        if submitted_answer is None or str(submitted_answer).strip() == &quot;&quot;:&#10;            is_correct = False&#10;            attempted = False&#10;        else:&#10;            attempted = True&#10;            # For MCQ multiple correct, compare as set&#10;            if exam_name == &quot;JEE_ADVANCED&quot; and question_type == &quot;MCQ_MULTIPLE&quot;:&#10;                if isinstance(correct_answer, list):&#10;                    submitted_set = set(str(submitted_answer).replace(&quot; &quot;, &quot;&quot;).upper())&#10;                    correct_set = set(&quot;&quot;.join([str(x).upper() for x in correct_answer]))&#10;                    is_correct = submitted_set == correct_set&#10;                else:&#10;                    is_correct = str(submitted_answer).strip().lower() == str(correct_answer).strip().lower()&#10;            else:&#10;                is_correct = str(submitted_answer).strip().lower() == str(correct_answer).strip().lower()&#10;&#10;        # Score calculation&#10;        if attempted:&#10;            if is_correct:&#10;                score = marks_correct&#10;            else:&#10;                score = marks_incorrect&#10;        else:&#10;            score = marks_unattempted&#10;&#10;        total_score += score&#10;        results.append({&#10;            'question_number': q_num,&#10;            'correct_answer': correct_answer,&#10;            'submitted_answer': submitted_answer,&#10;            'is_correct': is_correct,&#10;            'score': score&#10;        })&#10;&#10;    # Print summary&#10;    print(f&quot;Total Questions: {len(generated_paper)}&quot;)&#10;    print(f&quot;Total Score: {total_score}&quot;)&#10;    print(&quot;Detailed Results:&quot;)&#10;    for res in results:&#10;        print(f&quot;Q{res['question_number']}: Submitted: {res['submitted_answer']} | Correct: {res['correct_answer']} | {'Correct' if res['is_correct'] else 'Incorrect'} | Score: {res['score']}&quot;)&#10;&#10;    return {&#10;        'score': total_score,&#10;        'total_questions': len(generated_paper),&#10;        'results': results&#10;    }" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>